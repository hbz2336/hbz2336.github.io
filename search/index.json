[{"content":"Loader原理 loader概念 帮助webpack将不同类型的文件转换为webpack可识别的模块\nloader执行顺序 分类\npre：前置loader normal：普通loader inline：内联loader post：后置loader 执行顺序\n四类loader的执行顺序是：pre -\u0026gt; normal -\u0026gt; inline -\u0026gt; post 相同优先级的loader执行顺序：从右到左或从下到上 ","date":"2025-03-26T20:11:27+08:00","permalink":"http://localhost:1313/p/webpack%E4%B9%8Bloader/","title":"webpack之loader"},{"content":"webpack高级 为了让代码在编译/运行时的性能更好，从以下角度进行优化：\n提升开发体验 提升打包构建速度 减少代码体积 优化代码运行性能 1.提升开发体验 SourceMap SourceMap是webpack提供的一个功能，可以方便调试代码，让浏览器可以显示源码，而不是编译后的代码。让浏览器提示源代码文件出错位置，快速找到错误根源。 SourceMap（源代码映射）会生成一个xxx.map文件，这个文件就是用来映射源代码和编译后的代码之间的对应关系。\n使用\n开发模式：clean-module-source-map 优点：打包编译速度快，只包含行映射 缺点：没有列映射 生产模式：source-map 优点：包含行和列映射 缺点：打包编译速度慢，文件大 2.提升打包构建速度 修改了一个模块时，webpack默认会将所有代码全部重新打包编译，速度很慢。所以需要做到修改某个模块，就只有这个模块代码要重新打包编译，这样打包速度会很快。\nHotModuleReplacement HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除代码，不重载整个页面。\n1 2 // 当修改css模块 控制台会打印以下信息 不会重载整个页面 [HMR] - ./src/css/index.css 1 2 3 4 5 6 7 8 // 当修改js模块 控制台会打印以下信息 不会重载整个页面 [HMR] - ./src/js/count.js if (module.hot) { // 判断是否支持热更新 module.hot.accept(\u0026#34;./js/count.js\u0026#34;); module.hot.accept(\u0026#34;./js/sum.js\u0026#34;); } 如果将来开发项目，会使用其他的loader来解决：如vue-loader、react-hot-loader。 HMR开发模式可以，生产模式不行。\noneOf 保证每个文件只能被其中一个loader配置处理，减少打包时间\n不加oneOf,就是if/if/if执行，加了则是if/else if/else执行\ninclude/exclude 检测文件是否需要被loader处理，只针对js文件，css文件不需要\nCache 每次打包时js文件都要经过Eslint检查和Babel编译，如果文件内容没有变化，就不需要重复执行，可以缓存起来，提高打包速度。\nThead 多个loader并行执行，提高打包速度。\n对js文件处理主要是eslint、babel、terser三个工具，所以要提升它们的运行速度。\n多进程打包：开启电脑的多个进程同时干一件事，速度更快。 需要注意：仅在特别耗时的操作中使用，因为每个进程就有大约600ms左右的开销。\n启动进程的数量就是CPU的核数。\n3.减少代码体积 开发时引用了第三方工具函数库或者组件库。\n如果没有特殊处理的话打包时会打包引入整个库，但实际上我们可能只用了很小的一部分功能。如果整个库都打包，那么体积就会很大。\nTree Shaking 通常用于描述移除javascript代码中未引用的代码。它依赖于ES Module。\nwebpack的配置中默认开启了Tree Shaking。\nBabel Babel为编译的每个文件都插入了辅助代码，这些辅助代码会增加代码体积。可以将这些辅助代码作为一个独立模块，来避免重复引入。\n@babel/plugin-transform-runtime:禁用了Babel自动对每个文件的runtime注入，而是通过一个单独的runtime模块来注入,并且所有辅助代码从这里引入。\nImage Minimizer 图片体积大，将来请求速度会变慢。\n无损压缩 有损压缩： 图片质量受影响 4.优化代码运行性能 Code Splitting 打包代码时会将所有的js都打包到一个文件中，如果一个页面需要引入多个js文件，那么就会导致页面加载速度变慢。 代码分割：1.将代码分割成多个文件 2.按需加载，提高页面加载速度。\n公共代码（模块复用代码）单独打包成一个文件，减小体积。\nPreload/Prefetch 此前已经做了代码分割，同时会使用import动态导入语法来进行按需加载（比如路由懒加载） 但是加载速度还不够好，如果资源大，用户会感觉到卡顿。所以需要用到preload/prefetch技术。\npreload：告诉浏览器立刻加载资源。 prefetch：告诉浏览器在空闲时才加载资源。 共同点： 都只会加载资源，并不执行，都有缓存。 区别 Preload加载优先级高，Prefetch加载优先级低。 Preload只能加载当前页面需要使用的资源，Prefetch可以加载当前页面和未来页面可能需要使用的资源。 总结：当前页面优先级高的资源用Preload加载。下一个页面需要使用的资源用Prefetch加载。 Core-js 过去用babel对js代码进行兼容性处理，其中使用@babel/preset-env智能预设来处理兼容性问题。 它能将ES6的一些语法进行编译转换，比如箭头函数，扩展运算符等，但如果是async函数、promise、setTimeout、setInterval等，它无法处理，需要使用core-js来处理。\ncore-js是专门用来做ES6以及以上API的polyfill的，它提供了一些兼容性API，比如Promise、Set、Map等，以及一些新的API，比如async、await、fetch、Object.assign等。\npolyfill：一个功能缺失的补丁，比如Promise、Set、Map等，让我们在不兼容某些新特性的浏览器上，使用这些新特性。\nPWA 渐进式网络应用程序（Progressive Web Apps）：允许用户在浏览器中运行，并且具有网络功能。在离线时应用程序能够继续运行，内部通过Service Worker来实现。\n","date":"2025-03-22T20:26:45+08:00","permalink":"http://localhost:1313/p/webpack%E9%AB%98%E7%BA%A7/","title":"webpack高级"},{"content":"webpack 1.前言 1.1 为什么需要打包工具 开发时，会使用框架(React/vue),ES6模块化语法，less、sass等css预处理器等语法进行开发。 这样的代码想在浏览器运行必须经过编译成浏览器能识别的js、css等语法才能运行。 所以需要打包工具，同时打包工具还能压缩代码、做兼容性处理、提升代码性能等。\n1.2 有哪些打包工具 Grunt Gulp Parcel Rollup Webpack Vite \u0026hellip;\u0026hellip; 2.基本使用 webpack是一个静态资源打包工具。 它会以一个或者多个文件作为打包的入口，将我们整个项目所有文件编译组合成一个或者多个文件输出出去。 输出的文件就是编译好的文件，可以在浏览器运行。 webpack输出的文件叫做bundle。\n2.1 功能介绍 webpack本身功能是有限的。\n开发模式：仅能编译JS中的ES Module语法 生产模式：能编译JS中的ES Module语法，还能压缩代码 2.2 开始使用 2.2.1 资源目录 1 2 3 4 npm init -y 初始化包文件(package.json) npm i webpack webpack-cli -D 安装后可以执行webpack指令 npx 将node_modules中的.bin文件临时添加为环境变量 这样可以在控制台之间访问一些命令 npx webpack ./src/main.js --mode=development 指定模式打包（此处为开发模式） prodution为生产模式 体积很小 默认webpack会将打包文件输出到dist目录下\nwebpack本身功能比较少，只能处理js资源，一旦遇到css等其他资源就会报错。\n3.基本配置 commonJS模块化\n3.1 五个核心概念 entry（入口） 指示webpack从哪个文件开始打包 output（输出） 指示webpack打包完的文件输出到哪里去，如何命名 loader（加载器） webpack本身只能处理js、json等资源，其他资源需要借助loader，webpack才能解析 plugins（插件） 扩展webpack的功能 mode（模式） 主要有两种模式：开发模式和生产模式 1 npx webpack 在项目中找到webpack.config.js进行配置读取 执行相应的打包动作 3.2 开发模式介绍 开发代码使用的模式。\n编译代码，使浏览器识别运行 代码质量检查，树立代码规范 3.3 生产模式介绍 4.处理样式资源 webpack本身不能识别样式资源，需要借助loader帮忙解析\n4.1 处理css资源 官方文档可看（css-loader、style-loader）\n4.2 处理less资源 官方文档可看（less-loader）\n4.3 处理sass和scss资源 官方文档可看（sass-loader、scss-loader）\n4.4 处理stylus资源 官方文档可看（stylus-loader） 在样式文件中逗号、冒号、分号等符号可以省略\n5.处理图片资源 在webpack4中处理图片资源通过file-loader和url-loader进行处理 webpack4已经将这两个loader功能内置在webpack中，所以不需要再安装，简单配置即可。\n图片转为base64编码（长字符串），减少http请求次数，减小服务器压力。缺点：Base64编码后体积增加约33%。\n每张图片都是一个独立的文件，浏览器需要为每个文件发起一次 HTTP 请求。 图片数据被转换为字符串，直接嵌入到代码文件中。当浏览器加载代码文件时，图片数据已经包含在其中，无需额外请求。 将小图片转为 Base64 编码后内联到代码文件中，通过“合并请求”减少了 HTTP 请求次数，但需要权衡体积、缓存等因素。通常建议仅对极小且不常变动的图片使用这种方式。 5.1 处理字体图标资源 iconfont矢量图标\nUnicode IE6以上能用 兼容性较好 Font class IE8以上能用 用法简单 比较推荐 Symbol IE9以上能用 5.2 处理其他资源 如音视频资源、excel/zip等资源\n6.处理js资源 做兼容性处理，对代码格式进行要求，用专业工具检测代码格式否符合规范，不符合规范会报错。\n针对js兼容性处理，使用babel完成 * 针对css兼容性处理，使用postcss完成 针对html兼容性处理，使用html-webpack-plugin完成 针对代码格式，使用eslint完成 * 针对代码质量，使用stylelint完成 先完成eslint，检测代码格式，再检测代码质量，再检测css兼容性，再检测html兼容性，再检测js兼容性。\n6.1 Eslint eslint是一个代码格式检测工具，可以检测js/jsx/ts代码格式是否正确，不符合规范会报错。\n6.1.1 配置文件 配置文件有多种写法：\n.eslintrc.*: 新建文件，位于项目根目录下，文件名可以自定义，后缀名可以自定义，文件内容可以自定义，文件内容可以写json、yaml、js、ts等格式。 .eslintrc .eslintrc.js .eslintrc.json 区别在于配置格式不一样 package.json中eslintConfig:不需要创建文件，在原有文件基础上写。 6.2 Babel babel是一个js编译器，可以将es6语法编译成es5语法，让浏览器能识别。\n6.2.1 配置文件 配置文件有多种写法：\nbabel.config.js: 新建文件，位于项目根目录下，文件名可以自定义，后缀名可以自定义，文件内容可以自定义，文件内容可以写json、yaml、js、ts等格式。 .babelrc.*: 新建文件，位于项目根目录下，文件名可以自定义，后缀名可以自定义，文件内容可以自定义，文件内容可以写json、yaml、js、ts等格式。 在package.json中babel: 不需要创建文件，在原有文件基础上写。 7.处理html资源 手动引入的js不需要了，通过插件自动引入 通过插件HtmlWebpackPlugin\n8.开发服务器\u0026amp;自动化 每次都需要改动打包后才能看到效果 非常麻烦，希望一切自动化 通过插件webpack-dev-server npx webpack serve 启动命令 监视文件 一旦发现变化 就立刻打包 也叫做热更新 会自动刷新页面 npx webpack serve --config ./config/webpack.dev.js 开发模式运行 npx webpack --config ./config/webpack.prod.js 生产模式打包(代码会压缩)\n1 2 3 4 5 6 7 // package.json中的一些启动命令配置 // 除了start 命令，其他命令都是通过 npm run 命令来执行的 \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;npm run dev\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;webpack serve --config ./config/webpack.dev.js\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack --config ./config/webpack.prod.js\u0026#34; } 9.css处理 提取css成为单独的文件 css文件目前被打包到js文件中，当js加载时，会创建一个style标签来生成样式，有可能出现闪屏现象（先解析js再解析css），用户体验不好，单独的css文件通过link标签加载，性能会更好。\ncss的兼容性处理 css的兼容性处理，主要是针对IE浏览器，IE浏览器不支持css3新特性，需要做兼容性处理。\n1 2 3 4 5 // 在package.json中添加以下代码 进行浏览器的兼容性程度配置 // 三个参数取交集 （最近的两个版本要覆盖99%的浏览器 其中已死的浏览器不要） \u0026#34;browserslist\u0026#34;:[ \u0026#34;last 2 version\u0026#34;, \u0026#34;\u0026gt; 1%\u0026#34;, \u0026#34;not dead\u0026#34; ] 在css中，使用浏览器前缀来兼容不同版本的浏览器。以下是一些常见的浏览器前缀: 前缀有-webkit、-moz、-ms、-o。\ncss压缩 采用CssMinimizerPlugin插件进行配置\n就此webpack基础部分已完结~~~\n","date":"2025-03-20T23:33:55+08:00","permalink":"http://localhost:1313/p/webpack%E5%9F%BA%E7%A1%80/","title":"webpack基础"},{"content":"内容概览 websocket的出现，使浏览器具备了双向通信的能力。本文介绍Websocket如何建立连接，交换数据的细节，以及数据帧的格式。此外针对Websocket的安全攻击以及协议是如何抵御类似攻击的。\n什么是websocket HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。\n双向实时通信 降低延迟 更高效的资源利用，可以减少重复请求和响应的开销，因为连接只需要建立一次。 websocket有哪些优点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // 客户端id let timer = null; const uid = \u0026#39;hsdhjasdhj\u0026#39;; // 表示是否手动关闭连接 let isHandle = false; let ws = new WebSocket(`ws://localhost:8081/ws/${uid}`); // 调用成功 const openHandle = ()=\u0026gt; { console.log(\u0026#39;ws连接成功了\u0026#39;); } // 停止服务 const closeHandle = ()=\u0026gt; { console.log(\u0026#39;ws关闭成功了\u0026#39;); if(!isHandle){ // 尝试重连方法 restart(); } isHandle = false; } // 服务端有响应 const messageHandle = ({ data })=\u0026gt; { // 在这里调用方法 在服务器有响应的情况下会一直执行 console.log(data, \u0026#39;接收到的服务端消息\u0026#39;) console.log(\u0026#39;前端接收到消息了\u0026#39;); } // 接口错误 const errorHandle = ()=\u0026gt; { console.log(\u0026#39;ws出错了\u0026#39;); } ws.addEventListener(\u0026#39;open\u0026#39;,openHandle); ws.addEventListener(\u0026#39;close\u0026#39;, closeHandle); ws.addEventListener(\u0026#39;message\u0026#39;,messageHandle); ws.addEventListener(\u0026#39;error\u0026#39;,errorHandle); // 向服务器发送消息 const sendMessage = () =\u0026gt; { ws.send(\u0026#39;向服务器发送1\u0026#39;)； } // 关闭连接 const closeWs = () =\u0026gt; { isHandle = true; ws.close(); } // 重连 setInterval restart const restart = () =\u0026gt; { console.log(\u0026#39;客户端与服务端连接失败，准备开始重连\u0026#39;); timer = setInterval(()=\u0026gt;{ console.log(\u0026#39;重连中....\u0026#39;); // 新的websocket ws = new WebSocket(`ws://localhost:8081/ws/${uid}`); if(ws.readyState === 0){ clearInterval(timer); timer = null; // 重连成功 需要重新绑定事件 ws.addEventListener(\u0026#39;open\u0026#39;,openHandle); ws.addEventListener(\u0026#39;close\u0026#39;, closeHandle); ws.addEventListener(\u0026#39;message\u0026#39;,messageHandle); ws.addEventListener(\u0026#39;error\u0026#39;,errorHandle); } }, 1000); } // 心跳机制 // setInterval 持续给websocket服务器发送ping包 // websocket的卸载 tryOnmounted(()=\u0026gt;{ closeWs(); }) 在请求头的upgrade把http修改为websocket\nwebsocket心跳机制 为了保持websocket稳定的长连接，在连接建立之后，服务器和客户端之间通过心跳包来保持连接状态，以防止连接因为长时间没有数据传输而被切断。 心跳包：一种特殊的数据包，不包含任何实际数据，仅用来维持连接状态。一个空的数据帧，确保链接仍然有效，避免长时间没有数据传输而被中断。\nwebsocket限制 不提供加密功能，如果有安全上的需求，如ssl协议，设置黑白名单 不支持古老的浏览器。不支持IE10以前的版本 需要优化 轮询 客户端定期向服务器发送请求\n长轮询 在客户端发出请求后，保持连接打开，等待新数据响应后再关闭连接\ncomet 保持长连接，再返回请求后继续保持连接打开，并允许服务器通过流式传输，iframe等推送技术\n","date":"2025-03-20T18:57:34+08:00","image":"http://localhost:1313/p/websocket/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/p/websocket/","title":"Websocket"},{"content":"jekins 1.1 持续集成 持续集成指频繁的将代码集成到主干。好处：\n快速发现错误。定位错误也比较容易。 防止分支大幅偏离主干。 持续集成强调开发人员提交了新代码，立刻进行构建、单元测试。根据测试结果，可以确定新代码和原有代码能否正确的集成在一起。\n1.2 持续交付 持续交付指的是频繁的将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。进入类生产环境。\n1.3 持续部署 自动部署生产环境。\njekins详解 持续集成的操作流程 根据持续集成的设计，代码从提交到生产，整个过程有以下几步。\n提交 开发者向代码仓库提交代码（commit）。\n测试(第一轮) 代码仓库对commit操作配置了钩子(hook)，只要提交代码或者合并进主干，就会跑自动化测试。\n测试的种类：\n单元测试: 针对函数或模块的测试。（程序员自测居多） 集成测试：针对整体产品的某个功能的测试，又称功能测试。 端对端测试：从用户界面直达数据库的全链路测试。 第一轮至少要跑单元测试。\n构建 通过第一轮测试，代码就可以合并进主干进行交付。 交付后，进行构建，再进入第二轮测试。构建是指将源码转换为可运行的实际代码，比如安装依赖，配置各种资源等等。\n常用的构建工具有：\njekins Travis codeship strider 测试（第二轮） ","date":"2025-03-18T23:46:45+08:00","image":"http://localhost:1313/p/ci/cd%E7%9B%B8%E5%85%B3/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/p/ci/cd%E7%9B%B8%E5%85%B3/","title":"CI/CD相关"},{"content":"场景 2.1 js超过Number最大值的数怎么处理 JavaScript里的Number表示的安全整数范围是 -(2^53 - 1) 到 2^53 - 1，超出的话可能会出现精度丢失问题。Number.MIN_SAFE_INTEGER 和 Number.MAX_SAFE_INTEGER\nBigInt 内置的全局函数 只支持整数 1 const bigNum = BigInt(\u0026#39;124323131232231232312323232123\u0026#39;); decimal.js 用于任意精度十进制算术的 JavaScript 库 可整数可小数 1 const decimal = new Decimal(\u0026#34;1e+308\u0026#34;); // 科学计数法 表示1后面跟着308个0 big.js 可整数可小数\n格式化成用户好读的格式，比如1亿\n表单校验，不允许用户输入超过多少位的数字\n2.2 如何解决页面请求接口大规模并发问题 滑动窗口：算法，专门来控制流量的。\n背景：数据采集平台，低代码编辑平台，有序稳定发送到后端。\n方案：\n请求队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class RequestQueue { constructor(maxConcurrent){ this.maxConcurrent = maxConcurrent; // 最大并发请求数 this.currentConcurrent = 0; // 当前并发请求数 this.queue = []; //请求队列 } // 加入队列 处理队列里的事情 add(request){ return new Promise((resolve, reject) =\u0026gt; { this.queue.push({request, resolve, reject}); this.processQueue(); }) } processQueue(){\tif(this.queue.length \u0026gt; 0 \u0026amp;\u0026amp; this.currentCouncurrent \u0026lt; this.maxConcurrent){ const {request, resolve, reject} = this.queue.shift(); this.currentConcurrent++; request().then(resolve).catch(reject).finally(()=\u0026gt;{ this.currentConcurrent--; this.processQueue(); }) } } } function fetchData(url){ return fetch(url).then(response=\u0026gt;response.json()); } // 使用请求队列 const requestQueue = new RequestQueue(5); // 设定最大并发请求数为5 const url = [ \u0026#39;https://api.example.com/data1\u0026#39;, \u0026#39;https://api.example.com/data2\u0026#39;, // ... ]; const requests = urls.map(url=\u0026gt;{ return ()=\u0026gt;{ fetchData(url) } }); Promise.all(requests.map(request=\u0026gt;requestQueue.add(request))) .then(requests=\u0026gt;{ console.log(\u0026#39;所有请求已完成\u0026#39;, requests); }) .catch(error=\u0026gt;{ console.log(\u0026#39;请求失败\u0026#39;, error); }); 防抖(debounce)/节流(throttle)\n防抖：指定时间内只执行一次。常用输入搜索框。 节流：指定时间间隔内函数执行一次。常用窗口的resize、scroll事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function debounce(func, wait){ let timeout; return function(...args){ clearTImeout(timeout); timeout = setTimeout(()=\u0026gt;{ func.apply(this,args); }, wait); } } // 使用防抖 const debouncedFetchData = debounce((query)=\u0026gt;{ fetchData(`/api/search?q=${query}`).then(data=\u0026gt;{ console.log(data); }); }, 300); // 输入框事件监听 document.getElementById(\u0026#39;search-input\u0026#39;).addEventListener(\u0026#39;input\u0026#39;,(event)=\u0026gt;{ debouncedFetchData(event.target.value); }); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function throttle(func,limit){ let inThrottle; return funtion(...args){ if(!inThrottle){ func.apply(this, args); inThrottle = true; setTimeout(()=\u0026gt;inThrottle = false, limit); } } } // 使用节流函数 const throttledFetchData = throttle(()=\u0026gt;{ fetchData(`/api/search?q=${query}`).then(data=\u0026gt;{ console.log(data); }); }, 1000); //窗口滚动事件监听 window.addEventListener(\u0026#39;scroll\u0026#39;, throttledFetchData); 分页加载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 let currentPage = 1; const pageSize = 20; let isLoading = false; function loadMoreData(){ if(isLoading) return; isLoading = true; fetch(`/api/items?page=${currentPage}\u0026amp;size=${pageSize}`).then(response=\u0026gt;response.json()).then(data=\u0026gt;{ //处理数据并且更新页面 const container = document.getElementById(\u0026#39;item-container\u0026#39;); data.items.forEach(item=\u0026gt;{ const itemElement = document.createElement(\u0026#39;div\u0026#39;); itemElement.textContent = item.name; container.appendChild(itemElement); }); currentPage++; isLoading = false; }) .then(error=\u0026gt;{ console.log(\u0026#39;加载数据失败\u0026#39;，error); isLoading = false; }) } //监听滚动事件 window.addEventListener(\u0026#39;scroll\u0026#39;,()=\u0026gt;{ if(window.innerHeight+window.scrollY\u0026gt;=document.body.offsetHeight){ loadMoreData(); } }); //初始化加载 loadMoreData(); 落地、反思 大数据量请求场景下，选用了请求队列，封装请求队列 防抖节流，用户交互层面上去解决减少请求的处理 lodash源码 分页、滚动加载，可视区绘制 2.3 请说说大文件上传 涉及用户自定模型1G以上\n遇到的问题：\n+ 网络断开，之前传的没了 + 传着传着，网络波动没了 + 关机了，想接着传，做不到 专业术语：断点续传、断开重连重传、切片上传\n方案\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 1.前端切片 chunk 1024M(1048576KB), 500K, const size = 1048576/500;// 切片的数量 2.将切片传递给后端，切的片要取名：hash,index 3.后端组合切片 前端切片： 1.主进程卡顿，webWorker多线程切片，处理完后交给主进程发送 2.切完之后，将blob存储到IndexedDB，下次用户进来之后，查询是否存在未完成上传的切片，有就继续上传 3.websocket，实时通知和请求序列的控制 wss（额外） 整体设计： 1.组件设计 2.props、事件、状态 3.拖拽上传、多文件选择 4.通用化不同文件的上传，上传统一协议 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;fileInput\u0026#34; /\u0026gt; \u0026lt;button onclick=\u0026#34;uploadFile()\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; const CHUNK_SIZE = 5 * 1024 * 1024; // 每块大小为5MB function uploadFile() { const file = document.getElementById(\u0026#39;fileInput\u0026#39;).files[0]; if (!file) { // eslint-disable-next-line no-alert alert(\u0026#39;请选择文件\u0026#39;); return; } const totalChunks = Math.ceil(file.size / CHUNK_SIZE); let currentChunk = 0; // 放入webWorker function uploadChunk() { if (currentChunk \u0026gt;= totalChunks) { console.log(\u0026#39;上传完成\u0026#39;); return; } const start = currentChunk * CHUNK_SIZE; const end = Math.min(start + CHUNK_SIZE, file.size); const chunk = file.slice(start, end); const formData = new FormData(); formData.append(\u0026#39;file\u0026#39;, chunk); formData.append(\u0026#39;chunkNumber\u0026#39;, currentChunk + 1); formData.append(\u0026#39;totalChunks\u0026#39;, totalChunks); fetch(\u0026#39;/upload\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: formData, }) .then((response) =\u0026gt; { if (response.ok) { currentChunk++; uploadChunk(); // 递归调用上传下一块 } else { console.error(\u0026#39;上传失败\u0026#39;); } }) .catch((error) =\u0026gt; { console.error(\u0026#39;上传失败\u0026#39;, error); }); } uploadChunk(); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.4 在前端怎么实现页面截图 背景：\n文档，导出内容png 内容导出为png 设计类软件，出图 方案：\ncanvas puppeteer（无头【headless】浏览器）：解决响应式问题的截图 html2canvas(canvas) =\u0026gt; 上传CDN 落地：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 1.封装截图工具，考虑通用性（全页面截图|局部截图|特定区域截图）body/header/dom 2.设计具体协议（函数式、组件式）：隐藏canvas 3.核心代码 { \u0026#34;dependencies\u0026#34;:{ \u0026#34;html2canvas\u0026#34;: \u0026#34;1.4.1\u0026#34; } } \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdeliver.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;screenshot-target\u0026#34; style=\u0026#34;padding: 20px; background: #f5f5f5\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;THis is the content to capture.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button onclick=\u0026#34;takeScreenshot()\u0026#34;\u0026gt;截图\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function takeScreenshot() { const element = document.getElementById(\u0026#39;screenshot-target\u0026#39;); html2canvas(element).then((canvas) =\u0026gt; { const img = canvas.toDataURL(\u0026#39;image/png\u0026#39;); const link = document.createElement(\u0026#39;a\u0026#39;); link.href = img; link.download = \u0026#39;screenshot.png\u0026#39;; link.click(); }); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.5 移动端适配问题如何解决 背景： 项目想支持PC、移动端\n方案：\n根据不同端来开发不同页面（成本高） 根据不同端加载不同的css样式 根据响应式，来运行不同的样式规则（常用） style预处理器来做 考虑的问题：\n1.设置视窗，通过元信息配置meta\n1 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34;\u0026gt; 2.掌握媒体查询\n1 2 3 4 5 6 7 8 9 10 body{ font-size: 16px; } // 当尺寸大于xxx小于xxx时，需要什么样式 @media(min-width: 780px) and (max-width: 1024px){ body{ font-size:18px; } } 3.弹性布局 flex布局\n主轴方向：flex-direction 对齐方式：justify-content、align-items 弹性属性：flex 4.图片响应式 picture/source标签\n5.rem\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 rem单位的基础值由html的font-size决定 em单位 html{ font-size:16px; } // 当尺寸大于xxx小于xxx时，需要什么样式 @media(min-width: 780px) and (max-width: 1024px){ body{ font-size:18px; } } .header{ font-size:1rem; } .header_title{ fonst-size:0.8em; } 2.6 如何修改第三方npm包 稳定库，直接扒下来，node_modules, 直接修改\npatch 方法\nfork package，自己维护\n背景：\n来自于设计、产品\n方案：\n稳定库，node_modules 直接改\npatch 方案 （短期简单的npm包可以做）\n1 2 3 4 5 6 7 8 9 10 11 12 13 npm i patch-package postinstall npm的钩子 1.prepare 2.postinstall 3.publish等 { \u0026#34;scripts\u0026#34;:{ \u0026#34;postinstall\u0026#34;: \u0026#34;patch-package\u0026#34; } } 创建补丁 npx patch-package rspack 这时候会在项目生成`patches/rspack+1.0.0.patch` fork（github fork）\n- 直接改源码，源码改完后，构建，发布到npm私服（verdaccio） 2.7 当QPS达到峰值时，该如何处理 当前端应用的QPS(每秒查询次数)达到峰值时，会对服务器和应用造成很大的压力，甚至可能导致系统崩溃。为了解决这个问题，需要优化和管理高并发请求。\n方案：\n- 请求限流（全栈，后端处理）redis检查频率 请求太多抛出异常 请求合并\n短时间内的请求进行合并，以此降低服务端压力 防抖：一段时间内只进行一次请求 节流：一个时间间隔内进行一次请求 请求缓存\nswr里面针对于请求的内容缓存 请求参数、请求方法、请求逻辑依赖的内容没有发生变化，直接命中缓存。 任务队列\n滑动窗口，限定最大并发数 2.8 如何实现网页加载进度条 拿到进度、绘制进度（dom、svg）\n背景： 为了提升用户加载等待的体验，考虑使用加载进度条反馈给用户加载过程。\n方案：\n监听页面加载事件，来控制进度条绘制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #progress-bar { position: fixed; top: 0; left: 0; width: 100%; height: 4px; background-color: #29d; z-index: 9999; transition: width 0.4s ease; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;progress-bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function simulateLoadingProgress() { const progressBar = document.getElementById(\u0026#39;progress-bar\u0026#39;); let width = 0; const interval = setInterval(() =\u0026gt; { if (width \u0026gt;= 100) { clearInterval(interval); progressBar.style.width = \u0026#39;100%\u0026#39;; setTimeout(() =\u0026gt; { progressBar.style.display = \u0026#39;none\u0026#39;; }, 3000); } else { width += 5; progressBar.style.width = `${width}%`; } }, 1000); } window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { simulateLoadingProgress(); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Ajax拿到进度，svg/dom绘制进度\n","date":"2025-03-15T12:28:58+08:00","image":"http://localhost:1313/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%A2%98/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%A2%98/","title":"常见的一些场景题"},{"content":"手写 1.1 深拷贝实现 1.1.1 利用JSON.stringify和JSON.parse 1 2 3 4 5 6 function deepFunc(obj){ const obj2 = JSON.parse(JSON.stringify(obj)); return obj2; } // 缺点：不能处理函数、symbol类型的属性、Date对象、RegExp对象，会在序列化过程中丢失，不能处理循环引用的对象，会导致报错。 1.1.2 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function deepFunc(obj){ // 2.利用递归深拷贝 // 基本数据类型不存在嵌套结构 所以直接返回该值 不需要进一步递归处理 if (typeof obj !== \u0026#39;object\u0026#39; || obj === null) { return obj; } // 如果obj为数组 则创建一个空数组 进行递归处理 if (Array.isArray(obj)) { const clone = []; for (let i = 0; i \u0026lt; obj.length; i++) { clone[i] = deepFunc(obj[i]); } return clone; } // 如果obj为对象 则创建一个空对象 进行递归处理 const clone = {}; for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { clone[key] = deepFunc(obj[key]); } } return clone; } 1.2 手写apply、call、bind 用于改变this指向\n1.2.1 手写call方法 1.2.2 手写apply方法 1.2.3 手写bind方法 1.3 事件循环 javascript是单线程编程语言，同一时间执行一个任务。事件循环是js实现异步编程的核心机制，它允许程序在执行异步操作时不会阻塞主线程。 相关组件： 调用栈：执行栈，后进先出。用于存储正在执行的函数调用。当调用一个函数时，会将该函数的执行上下文压入调用栈；当函数执行完毕后，会将其执行上下文从调用栈中弹出。 任务队列：用于储存异步操作完成后的回调函数。分为宏任务和微任务。 事件循环：负责不断地从任务队列中取出任务并将其放入调用栈中执行。 工作流程： 执行同步代码，同步代码放入调用栈中执行，异步操作由浏览器处理。 异步操作完成后，对应的回调函数放入任务队列。 处理微任务队列。 处理宏任务队列。 循环执行3和4，知道任务队列和调用栈都为空。 1.4 函数柯里化 函数柯里化就是把一个多参数函数转换为一系列单参数函数的过程.\n优点：代码复用，减少代码量，对参数复用功能进行改进，也可进行兼容性的检测。\n如果参数达到length，直接计算结果，如果参数没有达到length，就返回一个函数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function sum(a,b,c){ console.log(a + b + c); } // curry即为柯里化函数 function curry(fn){ return function curried(...args){ if(args.length \u0026gt;= fn.length){ // 如果参数个数达到length,执行原函数 return fn.apply(this, args); }else{ //如果参数没有达到length,则返回新函数 return funciton (...args2){ return curried.apply(this, args.concat(args2)) } } } } let _sum = curry(sum); let functionA = _sum(1); let functionB = functionA(2); functionB(3);//6 其他例子\n1 2 3 4 5 6 7 8 9 10 11 12 function url_curring (protocol){ return function (hostname,pathname){ return `${protocol}${hostname}${pathname}` } } const url_https = url_curring(\u0026#39;https://\u0026#39;); const url1 = url_https(\u0026#39;www.baidu.com\u0026#39;, \u0026#39;/1\u0026#39;); const url2 = url_https(\u0026#39;www.baidu.com\u0026#39;, \u0026#39;/2\u0026#39;); const url3 = url_https(\u0026#39;www.baidu.com\u0026#39;, \u0026#39;/3\u0026#39;); console.log(url1, url2, url3); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 实现 add(1)(2)(3) = 6; add(1,2,3)(4) = 10; add(1)(2)(3)(4)(5) = 15; function add(...args){ let inner = function(...args2){ // ...展开运算符 args.push(...args2); let sum = args.reduce(function(prev,cur){ return prev+cur; },0); return inner; } return inner; } 1.5 数组扁平化 将一个多维数组递归地扁平化处理为一维数组.\n1.5.1 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 function flattern(arr){ const result = []; arr.forEach(item=\u0026gt;{ if(Array.isArray(item)){ result.push(...flattern(item)); }else{ result.push(item); } }) return result; } 1.5.2 使用reduce 1 2 3 4 5 function flattern(arr){ return arr.reduce((acc, item)=\u0026gt;{ return acc.concat(Array.isArray(item)?flattern(item):item); },[]) } 1.6 prototype 基本概念：在 JavaScript 里，每个函数都有一个 prototype 属性，这个属性指向一个对象，被称为原型对象。当使用该函数作为构造函数通过 new 关键字创建对象实例时，这些实例会继承原型对象上的属性和方法。\n优点： 1. 节省内存，像共享资源节省成本，而不是每个实例都复制一份，这样可以大大节省内存空间 2. 方便代码复用。 缺点：1.当 prototype 链很长或者嵌套复杂时，代码可读性降低，容易造成继承混淆 2.原型属性的修改影响广泛，改了一个影响全部。 1.7 Symbol 1.7.1 基本概念 symbol是ES6引入的一种新数据类型，表示独一无二的值，算基础类型。主要作用是创建对象的唯一属性名，以避免属性名冲突。\n1 2 3 4 const sym1 = Symbol(\u0026#39;description\u0026#39;); const sym2 = Symbol(\u0026#39;description\u0026#39;); console.log(sym1===sym2); // false 1.7.2 Symbol作为对象的属性键 1 2 3 4 5 6 7 const sym = Symbol(\u0026#39;myKey\u0026#39;); const obj = { [sym]: \u0026#39;value\u0026#39; }; console.log(obj[sym]);// \u0026#39;value\u0026#39; console.log(obj[\u0026#39;myKey\u0026#39;]);// undefined 1.7.3 Symbol的隐藏属性 Symbol属性不会出现在常规的对象属性遍历操作中，如for in、Object.keys()，它可以用来定义一些隐藏的或者内部的属性，防止外部不小心修改。\n1 2 3 4 5 6 7 8 9 const sym = Symbol(\u0026#39;hiddenProperty\u0026#39;); const obj = { [sym]: \u0026#39;secret\u0026#39;, normalProp: \u0026#39;visible\u0026#39; } console.log(Object.keys(obj));// [\u0026#39;normalProp\u0026#39;] console.log(Object.getOwnPropertyNames(obj));// [\u0026#39;normalProp\u0026#39;] console.log(Object.getOwnPropertySymbols(obj));// [Symbol(hiddenproperty)] 1.7.4 全局Symbol 有时候希望在不同模块内共享同一个Symbol，可使用Symbol.for\n1 2 3 4 5 const sym1 = Symbol.for(\u0026#39;sharedSymbol\u0026#39;); cosnt sym2 = Symbol.for(\u0026#39;sharedSymbol\u0026#39;); console.log(sym1 === sym2);//true // Symbol.for()不同于Symbol(),前者会检查全局Symbol注册表，而后者每次都会创建新的Symbol 1.8 promise 处理100个并发请求问题\n1.9 防抖/节流 ","date":"2025-02-22T16:31:07+08:00","image":"http://localhost:1313/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/","title":"常见的一些手写函数"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"http://localhost:1313/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"}]